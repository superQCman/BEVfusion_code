// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by pytorch, version 1.10
// ONNX IR version: 13
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <half.hpp>
#include "readTensorFromFile.h"
#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

/*
 * Operand:           Conv
 * Name in ONNX file: Conv_0
 */
static inline void node_Conv_0( const float x[1][80][360][360], const float w[80][80][3][3], const float bias[80], float y[1][80][360][360] )
{
	/* Conv
	 *
	 * auto_pad: NOTSET
	 * dilations: 1 1 
	 * group: 1
	 * kernel_shape: 3 3 
	 * pads: 1 1 1 1 
	 * strides: 1 1 
	 */
	for( uint32_t b=0; b<1; b++ ) {
	for( uint32_t m=0; m<80; m++) {
		for( int32_t o0=0, i0=-1; o0<360; o0++, i0+=1) {
		for( int32_t o1=0, i1=-1; o1<360; o1++, i1+=1) {
			y[b][m][o0][o1] = bias[m];
			for( int32_t c=0; c<80; c++ ) {
			for( uint32_t k0=0; k0<3; k0++ ) {
			for( uint32_t k1=0; k1<3; k1++ ) {
				int ii0 = i0+k0 * 1;
				if( ii0<0) continue;
				if( ii0>=360) continue;
				int ii1 = i1+k1 * 1;
				if( ii1<0) continue;
				if( ii1>=360) continue;
				y[b][m][o0][o1] += x[b][c][ii0][ii1] *w[m][c][k0][k1];
			} /* k */
			} /* k */
			} /* c */
		} /* o */
		} /* o */
	} /* m */
	} /* b */
}

/*
 * Operand:           Relu
 * Name in ONNX file: Relu_1
 */
static inline void node_Relu_1( const float X[1][80][360][360], float Y[1][80][360][360] )
{
	/*Relu*/
	float *X_ptr = (float*)X;
	float *Y_ptr = (float*)Y;
	uint32_t i;
	for( i=0; i<10368000; i++ )
		Y_ptr[i] = X_ptr[i] > 0 ? X_ptr[i] : 0;

}

/*
 * Operand:           Conv
 * Name in ONNX file: Conv_2
 */
static inline void node_Conv_2( const float x[1][80][360][360], const float w[80][80][3][3], const float bias[80], float y[1][80][180][180] )
{
	/* Conv
	 *
	 * auto_pad: NOTSET
	 * dilations: 1 1 
	 * group: 1
	 * kernel_shape: 3 3 
	 * pads: 1 1 1 1 
	 * strides: 2 2 
	 */
	for( uint32_t b=0; b<1; b++ ) {
	for( uint32_t m=0; m<80; m++) {
		for( int32_t o0=0, i0=-1; o0<180; o0++, i0+=2) {
		for( int32_t o1=0, i1=-1; o1<180; o1++, i1+=2) {
			y[b][m][o0][o1] = bias[m];
			for( int32_t c=0; c<80; c++ ) {
			for( uint32_t k0=0; k0<3; k0++ ) {
			for( uint32_t k1=0; k1<3; k1++ ) {
				int ii0 = i0+k0 * 1;
				if( ii0<0) continue;
				if( ii0>=360) continue;
				int ii1 = i1+k1 * 1;
				if( ii1<0) continue;
				if( ii1>=360) continue;
				y[b][m][o0][o1] += x[b][c][ii0][ii1] *w[m][c][k0][k1];
			} /* k */
			} /* k */
			} /* c */
		} /* o */
		} /* o */
	} /* m */
	} /* b */
}

/*
 * Operand:           Relu
 * Name in ONNX file: Relu_3
 */
static inline void node_Relu_3( const float X[1][80][180][180], float Y[1][80][180][180] )
{
	/*Relu*/
	float *X_ptr = (float*)X;
	float *Y_ptr = (float*)Y;
	uint32_t i;
	for( i=0; i<2592000; i++ )
		Y_ptr[i] = X_ptr[i] > 0 ? X_ptr[i] : 0;

}

/*
 * Operand:           Conv
 * Name in ONNX file: Conv_4
 */
static inline void node_Conv_4( const float x[1][80][180][180], const float w[80][80][3][3], const float bias[80], float y[1][80][180][180] )
{
	/* Conv
	 *
	 * auto_pad: NOTSET
	 * dilations: 1 1 
	 * group: 1
	 * kernel_shape: 3 3 
	 * pads: 1 1 1 1 
	 * strides: 1 1 
	 */
	for( uint32_t b=0; b<1; b++ ) {
	for( uint32_t m=0; m<80; m++) {
		for( int32_t o0=0, i0=-1; o0<180; o0++, i0+=1) {
		for( int32_t o1=0, i1=-1; o1<180; o1++, i1+=1) {
			y[b][m][o0][o1] = bias[m];
			for( int32_t c=0; c<80; c++ ) {
			for( uint32_t k0=0; k0<3; k0++ ) {
			for( uint32_t k1=0; k1<3; k1++ ) {
				int ii0 = i0+k0 * 1;
				if( ii0<0) continue;
				if( ii0>=180) continue;
				int ii1 = i1+k1 * 1;
				if( ii1<0) continue;
				if( ii1>=180) continue;
				y[b][m][o0][o1] += x[b][c][ii0][ii1] *w[m][c][k0][k1];
			} /* k */
			} /* k */
			} /* c */
		} /* o */
		} /* o */
	} /* m */
	} /* b */
}

/*
 * Operand:           Relu
 * Name in ONNX file: Relu_5
 */
static inline void node_Relu_5( const float X[1][80][180][180], float Y[1][80][180][180] )
{
	/*Relu*/
	float *X_ptr = (float*)X;
	float *Y_ptr = (float*)Y;
	uint32_t i;
	for( i=0; i<2592000; i++ )
		Y_ptr[i] = X_ptr[i] > 0 ? X_ptr[i] : 0;

}


void entry(float tensor_feat_in[1][80][360][360], float tensor_feat_out[1][80][180][180]){
	node_Conv_0( tensor_feat_in, tensor_0_weight, tensor_0_bias, tu0.tensor_7);
	node_Relu_1( tu0.tensor_7, tu1.tensor_8);
	node_Conv_2( tu1.tensor_8, tensor_3_weight, tensor_3_bias, tu0.tensor_9);
	node_Relu_3( tu0.tensor_9, tu1.tensor_10);
	node_Conv_4( tu1.tensor_10, tensor_6_weight, tensor_6_bias, tu0.tensor_11);
	node_Relu_5( tu0.tensor_11, tensor_feat_out);
}

static float tensor_0_weight[80][80][3][3];
auto temp_0_weight = read4DTensorFromFile<80,80,3,3>("../0.weight.txt");
for (size_t i = 0; i < 80; ++i) {
    for (size_t j = 0; j < 80; ++j) {
        for (size_t k = 0; k < 3; ++k) {
            for (size_t l = 0; l < 3; ++l) {
                tensor_0_weight[i][j][k][l] = temp_0_weight[i][j][k][l];
            }
        }
    }
}
static float tensor_0_bias[80];
auto temp_0_bias = read1DTensorFromFile<80>("../0.bias.txt");
for (size_t i = 0; i < 80; ++i) {
    tensor_0_bias[i] = temp_0_bias[i];
}
static float tensor_3_weight[80][80][3][3];
auto temp_3_weight = read4DTensorFromFile<80,80,3,3>("../3.weight.txt");
for (size_t i = 0; i < 80; ++i) {
    for (size_t j = 0; j < 80; ++j) {
        for (size_t k = 0; k < 3; ++k) {
            for (size_t l = 0; l < 3; ++l) {
                tensor_3_weight[i][j][k][l] = temp_3_weight[i][j][k][l];
            }
        }
    }
}
static float tensor_3_bias[80];
auto temp_3_bias = read1DTensorFromFile<80>("../3.bias.txt");
for (size_t i = 0; i < 80; ++i) {
    tensor_3_bias[i] = temp_3_bias[i];
}
static float tensor_6_weight[80][80][3][3];
auto temp_6_weight = read4DTensorFromFile<80,80,3,3>("../6.weight.txt");
for (size_t i = 0; i < 80; ++i) {
    for (size_t j = 0; j < 80; ++j) {
        for (size_t k = 0; k < 3; ++k) {
            for (size_t l = 0; l < 3; ++l) {
                tensor_6_weight[i][j][k][l] = temp_6_weight[i][j][k][l];
            }
        }
    }
}
static float tensor_6_bias[80];
auto temp_6_bias = read1DTensorFromFile<80>("../6.bias.txt");
for (size_t i = 0; i < 80; ++i) {
    tensor_6_bias[i] = temp_6_bias[i];
}
union tensor_union_0 {
float tensor_7[1][80][360][360];
float tensor_9[1][80][180][180];
float tensor_11[1][80][180][180];
};
static union tensor_union_0 tu0;

union tensor_union_1 {
float tensor_8[1][80][360][360];
float tensor_10[1][80][180][180];
};
static union tensor_union_1 tu1;

